<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEADLIGHT // CONSOLE [REALTIME]</title>
    
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    
    <style>
        :root {
            --bg: #09090b;
            --panel: #18181b;
            --border: #27272a;
            --text-main: #e4e4e7;
            --text-dim: #71717a;
            --accent: #f59e0b;
            --log-bg: #000000;
            --l-info: #3b82f6;
            --l-warn: #eab308;
            --l-err: #ef4444;
            --l-debug: #52525b;
            --l-time: #059669;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px;
        }
        h1 { margin: 0; font-size: 20px; letter-spacing: -1px; }
        .badge { 
            background: var(--accent); 
            color: #000; 
            padding: 2px 8px; 
            border-radius: 4px; 
            font-size: 12px; 
            font-weight: bold; 
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }
        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 6px;
        }
        .card-label { 
            color: var(--text-dim); 
            font-size: 11px; 
            text-transform: uppercase; 
            margin-bottom: 5px; 
            display: block;
        }
        .card-value { font-size: 24px; font-weight: 600; }

        .workspace {
            display: flex;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }

        .conn-panel {
            flex: 1;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
        }
        .panel-head {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border);
            font-weight: bold;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }
        .conn-list {
            overflow-y: auto;
            flex: 1;
            padding: 0;
            margin: 0;
            list-style: none;
        }
        .conn-row {
            padding: 8px 15px;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
            display: grid;
            grid-template-columns: 40px 1fr 80px;
            gap: 10px;
            align-items: center;
        }
        .conn-row:hover { background: #27272a; }
        .method { color: var(--accent); font-weight: bold; }

        .terminal-panel {
            flex: 2;
            background: var(--log-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            font-size: 12px;
        }
        .terminal-window {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            white-space: pre-wrap;
            font-family: 'Consolas', monospace;
        }
        
        .log-line { 
            display: block; 
            margin-bottom: 2px; 
            line-height: 1.4; 
            border-left: 2px solid transparent; 
            padding-left: 5px;
        }
        .log-line:hover { background: #111; border-left-color: var(--text-dim); }
        
        .ts { color: var(--l-time); opacity: 0.7; margin-right: 10px; }
        .lvl-INFO { color: var(--l-info); font-weight: bold; }
        .lvl-WARN { color: var(--l-warn); font-weight: bold; }
        .lvl-ERROR { color: var(--l-err); font-weight: bold; }
        .lvl-DEBUG { color: var(--l-debug); }
        .msg { color: var(--text-main); }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        .status-online { background: #10b981; }
        .status-offline { background: #ef4444; animation: none; }
        .status-connecting { background: #eab308; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* New: Stream indicator */
        .stream-mode {
            font-size: 10px;
            color: var(--text-dim);
            margin-left: 5px;
        }
    </style>
</head>
<body>

    <header>
        <div style="display:flex; align-items:center; gap:15px;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5 10 10 0 0 0-10 0 4 4 0 0 1-5-5 4 4 0 0 1-5-5z"></path>
                <path d="M12 22v-6"></path>
                <path d="M12 8V2"></path>
                <path d="M4.93 4.93l4.24 4.24"></path>
                <path d="M14.83 14.83l4.24 4.24"></path>
                <path d="M14.83 9.17l4.24-4.24"></path>
                <path d="M4.93 19.07l4.24-4.24"></path>
            </svg>
            <h1>DEADLIGHT <span style="opacity:0.5">//</span> PROXY</h1>
            <span class="stream-mode" id="mode-indicator">⚡ REALTIME</span>
        </div>
        <div>
            <span class="badge">v1.0.0</span>
            <span class="badge" id="api-status-badge" style="background:#333; color:#fff; margin-left:5px;">
                <span class="status-indicator status-connecting"></span>CONNECTING...
            </span>
        </div>
    </header>

    <div class="grid">
        <div class="card">
            <span class="card-label">Active Connections</span>
            <span class="card-value" id="val-active">--</span>
        </div>
        <div class="card">
            <span class="card-label">Total Handled</span>
            <span class="card-value" id="val-total">--</span>
        </div>
        <div class="card">
            <span class="card-label">Data Transferred</span>
            <span class="card-value" id="val-bytes">-- KB</span>
        </div>
        <div class="card">
            <span class="card-label">Uptime</span>
            <span class="card-value" id="val-uptime">--</span>
        </div>
    </div>

    <div class="workspace">
        <div class="conn-panel">
            <div class="panel-head">
                <span>TUNNELS</span>
                <span style="font-size: 10px; opacity: 0.7">LIVE</span>
            </div>
            <ul class="conn-list" id="conn-list">
                <li class="conn-row" style="text-align:center; display:block; opacity:0.5; padding:20px;">
                    Waiting for telemetry...
                </li>
            </ul>
        </div>

        <div class="terminal-panel">
            <div class="panel-head">
                <span>SYSTEM LOG</span>
                <div style="display:flex; gap:10px;">
                    <label style="font-size:10px;">
                        <input type="checkbox" checked id="auto-scroll"> AUTO-SCROLL
                    </label>
                </div>
            </div>
            <div class="terminal-window" id="terminal">
                <!-- Javascript will populate this -->
            </div>
        </div>
    </div>

<script>
    // ═══════════════════════════════════════════════════════════════════════
    // CONFIG
    // ═══════════════════════════════════════════════════════════════════════
    const API_BASE = 'http://127.0.0.1:8080';
    const SSE_ENDPOINT = API_BASE + '/api/stream';
    
    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════
    let lastLogLine = "";
    let eventSource = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_DELAY = 30000; // 30 seconds max
    
    // ═══════════════════════════════════════════════════════════════════════
    // UTILITY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════
    
    function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function formatUptime(seconds) {
        if (!seconds) return "0s";
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        
        if (h > 0) return `${h}h ${m}m ${s}s`;
        if (m > 0) return `${m}m ${s}s`;
        return `${s}s`;
    }

    function renderLogLine(line) {
        const regex = /^(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\s\[\s*([A-Z]+)\s*\]\s(.*)/;
        const match = line.match(regex);

        if (!match) {
            return `<div class="log-line"><span class="msg">${escapeHtml(line)}</span></div>`;
        }

        const [_, ts, level, msg] = match;
        const cleanLevel = level.trim();

        let richMsg = escapeHtml(msg)
            .replace(/(Connection \d+)/g, '<span style="color:#67e8f9">$1</span>')
            .replace(/([a-zA-Z0-9.-]+\.com:\d+)/g, '<span style="color:#fcd34d">$1</span>')
            .replace(/(direct:\/\/)/g, '<span style="color:#86efac">$1</span>');

        return `
            <div class="log-line">
                <span class="ts">${ts}</span>
                <span class="lvl-${cleanLevel}">[${level}]</span>
                <span class="msg" style="margin-left:10px">${richMsg}</span>
            </div>
        `;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function updateApiStatus(status) {
        const badge = document.getElementById('api-status-badge');
        const indicator = badge.querySelector('.status-indicator');
        
        if (status === 'online') {
            badge.innerHTML = '<span class="status-indicator status-online"></span>STREAMING';
            badge.style.background = '#10b981';
            badge.style.color = '#000';
            reconnectAttempts = 0;
        } else if (status === 'connecting') {
            badge.innerHTML = '<span class="status-indicator status-connecting"></span>CONNECTING...';
            badge.style.background = '#eab308';
            badge.style.color = '#000';
        } else {
            const retryIn = Math.min(2 ** reconnectAttempts, 30);
            badge.innerHTML = `<span class="status-indicator status-offline"></span>OFFLINE (retry ${retryIn}s)`;
            badge.style.background = '#ef4444';
            badge.style.color = '#fff';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DASHBOARD FROM SSE DATA
    // ═══════════════════════════════════════════════════════════════════════
    
    function updateDashboard(data) {
        const metrics = data.metrics;
        
        // Update metrics cards
        document.getElementById('val-active').innerText = 
            metrics.active_connections + " / " + metrics.total_connections;
        
        document.getElementById('val-total').innerText = metrics.total_connections;
        document.getElementById('val-bytes').innerText = formatBytes(metrics.bytes_transferred);
        document.getElementById('val-uptime').innerText = formatUptime(metrics.uptime);

        // Update protocol breakdown
        const list = document.getElementById('conn-list');
        let html = '';
        let hasActive = false;

        for (const [proto, stats] of Object.entries(metrics.protocols)) {
            if (stats.active > 0) {
                hasActive = true;
                html += `
                <li class="conn-row">
                    <span style="color:#555">PRO</span>
                    <span style="font-weight:bold">${proto}</span>
                    <span class="method" style="text-align:right">${stats.active} ACTIVE</span>
                </li>`;
            }
        }

        if (!hasActive) {
            html = '<li class="conn-row" style="opacity:0.5; justify-content:center;">No active connections</li>';
        }
        
        list.innerHTML = html;

        // Update logs (incremental)
        const logs = data.logs || [];
        const term = document.getElementById('terminal');
        
        let newLogs = [];
        
        if (lastLogLine === "") {
            newLogs = logs;
        } else {
            const lastIndex = logs.indexOf(lastLogLine);
            if (lastIndex !== -1) {
                newLogs = logs.slice(lastIndex + 1);
            } else {
                newLogs = logs;
            }
        }

        if (newLogs.length > 0) {
            lastLogLine = logs[logs.length - 1];

            newLogs.forEach(line => {
                const div = document.createElement('div');
                div.innerHTML = renderLogLine(line);
                term.appendChild(div);
            });

            if (document.getElementById('auto-scroll').checked) {
                term.scrollTop = term.scrollHeight;
            }
            
            while (term.childElementCount > 500) {
                term.removeChild(term.firstChild);
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SSE CONNECTION MANAGEMENT
    // ═══════════════════════════════════════════════════════════════════════
    
    function connectSSE() {
        updateApiStatus('connecting');
        
        console.log('[SSE] Connecting to', SSE_ENDPOINT);
        
        // Create EventSource
        eventSource = new EventSource(SSE_ENDPOINT);
        
        // Handle incoming dashboard updates
        eventSource.addEventListener('dashboard', (event) => {
            try {
                const data = JSON.parse(event.data);
                updateDashboard(data);
                updateApiStatus('online');
            } catch (err) {
                console.error('[SSE] Failed to parse dashboard data:', err);
            }
        });
        
        // Handle connection open
        eventSource.onopen = () => {
            console.log('[SSE] Connection established');
            updateApiStatus('online');
            reconnectAttempts = 0;
        };
        
        // Handle errors and reconnection
        eventSource.onerror = (err) => {
            console.error('[SSE] Connection error:', err);
            eventSource.close();
            updateApiStatus('offline');
            
            // Exponential backoff: 2s, 4s, 8s, 16s, 30s (max)
            reconnectAttempts++;
            const delay = Math.min(
                1000 * Math.pow(2, reconnectAttempts), 
                MAX_RECONNECT_DELAY
            );
            
            console.log(`[SSE] Reconnecting in ${delay/1000}s (attempt ${reconnectAttempts})...`);
            
            setTimeout(() => {
                connectSSE();
            }, delay);
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FALLBACK: Polling mode (if SSE not supported or fails repeatedly)
    // ═══════════════════════════════════════════════════════════════════════
    
    function switchToPollingMode() {
        console.warn('[SSE] Switching to polling fallback');
        
        document.getElementById('mode-indicator').textContent = 'POLLING';
        
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        
        async function poll() {
            try {
                const res = await fetch(API_BASE + '/api/dashboard');
                if (!res.ok) throw new Error(`API returned ${res.status}`);
                
                const data = await res.json();
                updateDashboard(data);
                updateApiStatus('online');
            } catch (err) {
                console.error('[Polling] Failed:', err);
                updateApiStatus('offline');
            }
        }
        
        // Poll every 3 seconds
        poll();
        setInterval(poll, 3000);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BROWSER COMPATIBILITY CHECK
    // ═══════════════════════════════════════════════════════════════════════
    
    function supportsSSE() {
        return typeof EventSource !== 'undefined';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZE
    // ═══════════════════════════════════════════════════════════════════════
    
    if (supportsSSE()) {
        console.log('[Init] Using SSE (Server-Sent Events) mode');
        connectSSE();
        
        // If SSE fails 10 times, switch to polling
        setTimeout(() => {
            if (reconnectAttempts > 10) {
                switchToPollingMode();
            }
        }, 60000); // After 1 minute
    } else {
        console.warn('[Init] Browser does not support SSE, using polling fallback');
        switchToPollingMode();
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (eventSource) {
            eventSource.close();
        }
    });
</script>
</body>
</html>