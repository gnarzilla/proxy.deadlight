#include "ui.h"
#include "assets.h"      // generated by xxd
#include <glib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <microhttpd.h>
#include "core/plugins.h"


static enum MHD_Result handle_api_connections(DeadlightContext *context, struct MHD_Connection *conn, const char *method);

/* ---------- Simple JSON helpers ---------- */
static int json_response(struct MHD_Connection *conn, const char *json)
{
    struct MHD_Response *resp = MHD_create_response_from_buffer(strlen(json),
                                                               (void *)json,
                                                               MHD_RESPMEM_MUST_COPY);
    MHD_add_response_header(resp, "Content-Type", "application/json");
    int ret = MHD_queue_response(conn, MHD_HTTP_OK, resp);
    MHD_destroy_response(resp);
    return ret;
}

/* Utility to get IP:Port string from a GSocketConnection */
static gchar *get_remote_addr_string(GSocketConnection *conn)
{
    if (!conn) {
        return g_strdup("N/A");
    }
    
    // Get the GSocketAddress object for the remote peer
    GSocketAddress *remote_address = g_socket_connection_get_remote_address(
        conn, NULL // GError
    );

    if (!remote_address) {
        return g_strdup("Unknown Address");
    }

    // Convert the GSocketAddress to a string (e.g., "192.168.1.1:12345")
    gchar *addr_str = g_socket_address_to_string(remote_address);
    
    g_object_unref(remote_address); // Free the GSocketAddress object
    
    return addr_str; // Caller must free this string
}

/* ---------- API: /api/status ---------- */
static enum MHD_Result
handle_api_status(DeadlightContext *context, struct MHD_Connection *conn, const char *method)
{
    if (strcmp(method, "GET") != 0) {
        return MHD_NO;
    }

    GString *json_str = g_string_new("{");

    g_mutex_lock(&context->stats_mutex);

    // --- Critical Section: Read all shared data ---
    double uptime = g_timer_elapsed(context->uptime_timer, NULL);
    guint64 active_conn = context->active_connections;
    guint64 total_conn = context->total_connections;
    guint64 bytes = context->bytes_transferred;
    GList *plugin_names = deadlight_plugins_get_all_names(context);
    
    g_mutex_unlock(&context->stats_mutex);

    // --- Build the JSON string from local copies ---
    gchar *bytes_str = deadlight_format_bytes(bytes);

    // All of these have a trailing comma because they are not the last item
    g_string_append_printf(json_str, "\"version\": \"%s\",", DEADLIGHT_VERSION_STRING);
    g_string_append_printf(json_str, "\"uptime_seconds\": %.2f,", uptime);
    g_string_append_printf(json_str, "\"connections_active\": %" G_GUINT64_FORMAT ",", active_conn);
    g_string_append_printf(json_str, "\"connections_total\": %" G_GUINT64_FORMAT ",", total_conn);
    g_string_append_printf(json_str, "\"bytes_transferred\": %" G_GUINT64_FORMAT ",", bytes);

    g_string_append_printf(json_str, "\"bytes_transferred_formatted\": \"%s\",", bytes_str);

    g_string_append(json_str, "\"plugins\": [");
    if (plugin_names) {
        GList *iterator = plugin_names;
        gboolean first = TRUE;
        while (iterator) {
            if (!first) {
                g_string_append(json_str, ",");
            }
            g_string_append_printf(json_str, "\"%s\"", (gchar*)iterator->data);
            first = FALSE;
            iterator = g_list_next(iterator);
        }
        g_list_free_full(plugin_names, g_free);
    }
    g_string_append(json_str, "]"); // End of array

    // The final closing brace for the object
    g_string_append(json_str, "}");

    enum MHD_Result ret = json_response(conn, json_str->str);

    g_free(bytes_str);
    g_string_free(json_str, TRUE);
    
    return ret;
}

/* ---------- Serve index.html ---------- */
static int handle_root(struct MHD_Connection *conn)
{
    const char *html = (const char *)src_ui_index_html;
    struct MHD_Response *resp = MHD_create_response_from_buffer(
        src_ui_index_html_len, (void *)html, MHD_RESPMEM_MUST_COPY);
    MHD_add_response_header(resp, "Content-Type", "text/html; charset=utf-8");
    int ret = MHD_queue_response(conn, MHD_HTTP_OK, resp);
    MHD_destroy_response(resp);
    return ret;
}

/* ---------- Main request dispatcher ---------- */
static enum MHD_Result
request_handler(void *cls,
                struct MHD_Connection *conn,
                const char *url,
                const char *method,
                const char *version,
                const char *upload_data,
                size_t *upload_data_size,
                void **con_cls)
{
    (void)cls; (void)version; (void)upload_data; (void)upload_data_size; (void)con_cls;

    
    DeadlightContext *context = cls;
    if (strcmp(url, "/") == 0 && strcmp(method, "GET") == 0) {
        return handle_root(conn);
    } 
    else if (strcmp(url, "/api/status") == 0 && strcmp(method, "GET") == 0) {
        return handle_api_status(context, conn, method);
    }
    else if (strcmp(url, "/api/connections") == 0 && strcmp(method, "GET") == 0) {
        return handle_api_connections(context, conn, method);
    }
 
    /* 404 Not Found */
    struct MHD_Response *resp = MHD_create_response_from_buffer(0, NULL, MHD_RESPMEM_PERSISTENT);
    int rc = MHD_queue_response(conn, MHD_HTTP_NOT_FOUND, resp);
    MHD_destroy_response(resp);
    return rc;
}

/* ---------- Server lifecycle ---------- */
static struct MHD_Daemon *ui_daemon = NULL;

void start_ui_server(DeadlightContext *context)
{
    const unsigned short ui_port = 8081;

    ui_daemon = MHD_start_daemon(MHD_USE_SELECT_INTERNALLY,
                                 ui_port,
                                 NULL,
                                 NULL,
                                 (MHD_AccessHandlerCallback) &request_handler, // Cast for strict compilers
                                 context, 
                                 MHD_OPTION_END);
    if (!ui_daemon) {
        g_error("Failed to start UI daemon on port %u", ui_port);
    } else {
        g_info("UI server listening on http://127.0.0.1:%u", ui_port);
    }
}

void stop_ui_server(void)
{
    if (ui_daemon) {
        MHD_stop_daemon(ui_daemon);
        ui_daemon = NULL;
    }
}

/* ---------- API: /api/connections ---------- */
static enum MHD_Result
handle_api_connections(DeadlightContext *context, struct MHD_Connection *conn, const char *method)
{
    if (strcmp(method, "GET") != 0) {
        return MHD_NO;
    }

    GString *json_str = g_string_new("[");
    gboolean first = TRUE;

    // Lock the mutex to safely iterate over the connections hash table
    g_mutex_lock(&context->stats_mutex);

    if (context->connections) {
        GHashTableIter iter;
        gpointer key, value;
        g_hash_table_iter_init(&iter, context->connections);
        while (g_hash_table_iter_next(&iter, &key, &value)) {
            DeadlightConnection *d_conn = (DeadlightConnection *)value;

            if (!first) {
                g_string_append(json_str, ",");
            }
            
            // Extract the data for the JSON response
            g_string_append_printf(json_str, "{"
                "\"id\": %" G_GUINT64_FORMAT ","
                "\"remote\": \"%s\","
                "\"proto\": \"%s\","
                "\"tx\": %" G_GUINT64_FORMAT ","
                "\"rx\": %" G_GUINT64_FORMAT
                "}",
                d_conn->id,
                d_conn->client_address ? d_conn->client_address : "N/A",
                deadlight_protocol_to_string(d_conn->protocol),
                d_conn->bytes_client_to_upstream,
                d_conn->bytes_upstream_to_client
            );
            first = FALSE;
        }
    }

    // Unlock the mutex as soon as we're done with the shared data
    g_mutex_unlock(&context->stats_mutex);

    g_string_append(json_str, "]");

    enum MHD_Result ret = json_response(conn, json_str->str);
    g_string_free(json_str, TRUE);

    return ret;
}